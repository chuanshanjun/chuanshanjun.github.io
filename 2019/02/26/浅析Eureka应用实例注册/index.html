<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>浅析Eureka应用实例注册 | ChuanShanJun&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="#Eureka应用实例注册 ###本文所使用到的包版本 spring-cloud-starter-netflix-eureka-client:2.0.2.RELEASE spring-cloud-netflix-eureka-client:2.0.2.RELEASE eureka-client:1.9.3 eureka-core:1.9.3 ##1.概述  图片来源芋道源码       蓝框部分,">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析Eureka应用实例注册">
<meta property="og:url" content="http://yoursite.com/2019/02/26/浅析Eureka应用实例注册/index.html">
<meta property="og:site_name" content="ChuanShanJun&#39;s Blog">
<meta property="og:description" content="#Eureka应用实例注册 ###本文所使用到的包版本 spring-cloud-starter-netflix-eureka-client:2.0.2.RELEASE spring-cloud-netflix-eureka-client:2.0.2.RELEASE eureka-client:1.9.3 eureka-core:1.9.3 ##1.概述  图片来源芋道源码       蓝框部分,">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/chuanshanjun/mess/master/%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E6%B3%A8%E5%86%8C.jpg">
<meta property="og:updated_time" content="2019-02-26T01:33:40.557Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅析Eureka应用实例注册">
<meta name="twitter:description" content="#Eureka应用实例注册 ###本文所使用到的包版本 spring-cloud-starter-netflix-eureka-client:2.0.2.RELEASE spring-cloud-netflix-eureka-client:2.0.2.RELEASE eureka-client:1.9.3 eureka-core:1.9.3 ##1.概述  图片来源芋道源码       蓝框部分,">
<meta name="twitter:image" content="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg">
  
    <link rel="alternate" href="/atom.xml" title="ChuanShanJun&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ChuanShanJun&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-浅析Eureka应用实例注册" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/02/26/浅析Eureka应用实例注册/" class="article-date">
  <time datetime="2019-02-26T01:32:43.000Z" itemprop="datePublished">2019-02-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅析Eureka应用实例注册
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#Eureka应用实例注册</p>
<p>###本文所使用到的包版本</p>
<p>spring-cloud-starter-netflix-eureka-client:2.0.2.RELEASE</p>
<p>spring-cloud-netflix-eureka-client:2.0.2.RELEASE</p>
<p>eureka-client:1.9.3</p>
<p>eureka-core:1.9.3</p>
<p>##1.概述</p>
<blockquote>
<p>图片来源<a href="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg" target="_blank" rel="noopener">芋道源码</a></p>
</blockquote>
<blockquote>
<p><img src="http://www.iocoder.cn/images/Eureka/2018_05_28/01.jpeg" alt="Eureka Client"></p>
</blockquote>
<blockquote>
<ul>
<li><strong>蓝框</strong>部分,为本文重点</li>
<li>非<strong>蓝框</strong>部分，为Eureka-Server的集群间复制注册的应用实例信息，不在本文内容范畴。</li>
</ul>
</blockquote>
<p>##2.Eureka-Client 发起注册</p>
<pre><code>@Singleton
public class DiscoveryClient implements EurekaClient {
    // ... 
    @Inject
    DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
                    Provider&lt;BackupRegistry&gt; backupRegistryProvider) {
        // ...           
        // 既不注册，也不拉取 那么不需要执行接下去的网络任务            
        if (!config.shouldRegisterWithEureka() &amp;&amp; !config.shouldFetchRegistry()) {
            // ...
            return;  // no need to setup up an network tasks and we are done
        }
        // ...
           // finally, init the schedule tasks (e.g. cluster resolvers, heartbeat, instanceInfo replicator, fetch
        // 初始化Scheduled任务    
        initScheduledTasks();
        // ...
    }
}
</code></pre><p><code>com.netflix.discovery.DiscoveryClient#DiscoveryClient(...)</code>构造DiscoveryClient中当配置文件<code>EurekaClientConfig.shouldRegisterWithEureka</code>以及<code>shouldFetchRegistry</code>都为false也就是既不注册，也不拉取，那么不需要执行接下去的网络任务。</p>
<p>如果正常注册或拉取时则会往下执行初始化排程任务<code>DiscoveryClient#initScheduledTasks()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">        // ...</span><br><span class="line">        if (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">            // ...</span><br><span class="line">            // 创建 应用实例信息复制器</span><br><span class="line">            // InstanceInfo replicator </span><br><span class="line">            instanceInfoReplicator = new InstanceInfoReplicator(</span><br><span class="line">                    this,</span><br><span class="line">                    instanceInfo,</span><br><span class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                    2); // burstSize</span><br><span class="line">			  // 创建 应用实例状态变更监听器	</span><br><span class="line">            statusChangeListener = new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getId() &#123;</span><br><span class="line">                    return &quot;statusChangeListener&quot;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                    if (InstanceStatus.DOWN == statusChangeEvent.getStatus() ||</span><br><span class="line">                            InstanceStatus.DOWN == statusChangeEvent.getPreviousStatus()) &#123;</span><br><span class="line">                        // log at warn level if DOWN was involved</span><br><span class="line">                        logger.warn(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        logger.info(&quot;Saw local status change event &#123;&#125;&quot;, statusChangeEvent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">			  // 注册 应用实例状态变更监听器</span><br><span class="line">            if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">                applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">		// 开始 应用实例信息复制器</span><br><span class="line">	           instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.info(&quot;Not registering with Eureka server per configuration&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">class InstanceInfoReplicator implements Runnable &#123;</span><br><span class="line">    private static final Logger logger = LoggerFactory.getLogger(InstanceInfoReplicator.class);</span><br><span class="line"></span><br><span class="line">    private final DiscoveryClient discoveryClient;</span><br><span class="line">    // 应用实例信息</span><br><span class="line">    private final InstanceInfo instanceInfo;</span><br><span class="line">    // 复制器执行频率    </span><br><span class="line">    private final int replicationIntervalSeconds;</span><br><span class="line">    private final ScheduledExecutorService scheduler;</span><br><span class="line">    // Scheduled执行结果的引用&lt;Future&gt;</span><br><span class="line">    private final AtomicReference&lt;Future&gt; scheduledPeriodicRef;</span><br><span class="line">    // 开启 标识位</span><br><span class="line">    private final AtomicBoolean started;</span><br><span class="line">    private final RateLimiter rateLimiter; // 限流相关 省略</span><br><span class="line">    private final int burstSize; // 限流相关 省略</span><br><span class="line">    private final int allowedRatePerMinute; // 限流相关 省略</span><br><span class="line"></span><br><span class="line">    InstanceInfoReplicator(DiscoveryClient discoveryClient, InstanceInfo instanceInfo, int replicationIntervalSeconds, int burstSize) &#123;</span><br><span class="line">        this.discoveryClient = discoveryClient;</span><br><span class="line">        this.instanceInfo = instanceInfo;</span><br><span class="line">        // 创建scheduler所需线程池 线程数1 线程工厂使用Guava的ThreadFactoryBuilder</span><br><span class="line">        // 设置线程名字方便识别线程 设置守护线程 随着程序的结束自动关闭</span><br><span class="line">        this.scheduler = Executors.newScheduledThreadPool(1,</span><br><span class="line">                new ThreadFactoryBuilder()</span><br><span class="line">                        .setNameFormat(&quot;DiscoveryClient-InstanceInfoReplicator-%d&quot;)</span><br><span class="line">                        .setDaemon(true)</span><br><span class="line">                        .build());</span><br><span class="line"></span><br><span class="line">        this.scheduledPeriodicRef = new AtomicReference&lt;Future&gt;();</span><br><span class="line">        // 默认开启为 false</span><br><span class="line">        this.started = new AtomicBoolean(false);</span><br><span class="line">        this.rateLimiter = new RateLimiter(TimeUnit.MINUTES);</span><br><span class="line">        this.replicationIntervalSeconds = replicationIntervalSeconds;</span><br><span class="line">        this.burstSize = burstSize;</span><br><span class="line"></span><br><span class="line">        this.allowedRatePerMinute = 60 * this.burstSize / this.replicationIntervalSeconds;</span><br><span class="line">        logger.info(&quot;InstanceInfoReplicator onDemand update allowed rate per min is &#123;&#125;&quot;, allowedRatePerMinute);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void start(int initialDelayMs) &#123;</span><br><span class="line">        // 使用AtomicBoolean的compareAndSet确保只有一个线程</span><br><span class="line">        // 执行if里面的方法</span><br><span class="line">        if (started.compareAndSet(false, true)) &#123;</span><br><span class="line">            // 初始化的时候应用信息设置为dirty </span><br><span class="line">            instanceInfo.setIsDirty();  // for initial register</span><br><span class="line">            // scheduler延迟执行一次任务 返回Future</span><br><span class="line">            Future next = scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS);</span><br><span class="line">            // 设置Scheduled执行结果的引用&lt;Future&gt; </span><br><span class="line">            scheduledPeriodicRef.set(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">    public boolean onDemandUpdate() &#123;</span><br><span class="line">        if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123;</span><br><span class="line">            if (!scheduler.isShutdown()) &#123;</span><br><span class="line">                scheduler.submit(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        logger.debug(&quot;Executing on-demand update of local InstanceInfo&quot;);</span><br><span class="line">                        // 获取上一次schedluer执行结果Future</span><br><span class="line">                        Future latestPeriodic = scheduledPeriodicRef.get();</span><br><span class="line">                        // 上一次执行结果存在并且还没有执行完毕</span><br><span class="line">                        if (latestPeriodic != null &amp;&amp; !latestPeriodic.isDone()) &#123;</span><br><span class="line">                            logger.debug(&quot;Canceling the latest scheduled update, it will be rescheduled at the end of on demand update&quot;);</span><br><span class="line">                            // 取消上次执行</span><br><span class="line">                            latestPeriodic.cancel(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 重新运行InstanceInfoReplicator的run()方法</span><br><span class="line">                        InstanceInfoReplicator.this.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.warn(&quot;Ignoring onDemand update due to stopped scheduler&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.warn(&quot;Ignoring onDemand update due to rate limiter&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // scheduler的执行逻辑</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 刷新应用实例的信息</span><br><span class="line">            discoveryClient.refreshInstanceInfo();</span><br><span class="line">            // isInstanceInfoDirty为true则返回dirty时间</span><br><span class="line">            Long dirtyTimestamp = instanceInfo.isDirtyWithTime();</span><br><span class="line">            if (dirtyTimestamp != null) &#123;</span><br><span class="line">                // 发起注册</span><br><span class="line">                discoveryClient.register();</span><br><span class="line">                // isInstanceInfoDirty置为false</span><br><span class="line">                instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            // 再次开启一个schedule 也就是 循环执行</span><br><span class="line">            Future next = scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">            // 设置Scheduled执行结果的引用&lt;Future&gt;</span><br><span class="line">            scheduledPeriodicRef.set(next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当instanceInfo信息变化的时候会将<code>isInstanceInfoDirty</code>设置为true,dirty的意思认为instanceInfo里的信息变化了认为其变<strong>“脏了”</strong>，在<code>run()</code>方法中只有数据变化了才会定时向Server发起注册。</p>
<p><code>scheduler.schedule(this, initialDelayMs, TimeUnit.SECONDS)</code>方法延迟<code>initialDelayMs</code>时间执行一次，但通过<code>run()</code> 中的finally再次执行<code>scheduler.schedule</code>方法，通过这样的办法形成了一个无限循环,如下图所示。</p>
<p><img src="https://raw.githubusercontent.com/chuanshanjun/mess/master/%E5%BE%AA%E7%8E%AF%E6%89%A7%E8%A1%8C%E6%B3%A8%E5%86%8C.jpg" alt="图片"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Singleton</span><br><span class="line">public class ApplicationInfoManager &#123;</span><br><span class="line">	// ...</span><br><span class="line">	protected final Map&lt;String, StatusChangeListener&gt; listeners;</span><br><span class="line">	// ...</span><br><span class="line">	@Inject</span><br><span class="line">    public ApplicationInfoManager(EurekaInstanceConfig config, InstanceInfo instanceInfo, OptionalArgs optionalArgs) &#123;</span><br><span class="line">        this.config = config;</span><br><span class="line">        this.instanceInfo = instanceInfo;</span><br><span class="line">        this.listeners = new ConcurrentHashMap&lt;String, StatusChangeListener&gt;();</span><br><span class="line">        if (optionalArgs != null) &#123;</span><br><span class="line">            this.instanceStatusMapper = optionalArgs.getInstanceStatusMapper();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.instanceStatusMapper = NO_OP_MAPPER;</span><br><span class="line">        &#125;</span><br><span class="line">		  </span><br><span class="line">        // Hack to allow for getInstance() to use the DI&apos;d ApplicationInfoManager</span><br><span class="line">        instance = this;</span><br><span class="line">    &#125;</span><br><span class="line">    //...	</span><br><span class="line">    public void registerStatusChangeListener(StatusChangeListener listener) &#123;</span><br><span class="line">        listeners.put(listener.getId(), listener);</span><br><span class="line">    &#125;</span><br><span class="line">	// ...</span><br><span class="line">	public static interface StatusChangeListener &#123;</span><br><span class="line">        String getId();</span><br><span class="line"></span><br><span class="line">        void notify(StatusChangeEvent statusChangeEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>com.netflix.appinfo.ApplicationInfoManager. StatusChangeListener</code>是一个静态的内部接口，<code>initScheduledTasks()</code>中的<code>statusChangeListener</code>重写了<code>getId()</code>和<code>notify()</code>这两个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (clientConfig.shouldOnDemandUpdateStatusChange()) &#123;</span><br><span class="line">                applicationInfoManager.registerStatusChangeListener(statusChangeListener);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initScheduledTasks()</code>中会读取<code>clientConfig.shouldOnDemandUpdateStatusChange</code>这个配置，当本地实例状态发生变更后会向远程server注册或者更新，配置默认为true，之后会注册到状态变更监听器上。</p>
<p>我们可以从上面的代码中看到<code>listeners</code>就是一个<code>ConcurrentHashMap</code>然后将<code>StatusChangeListener(状态变更监听器)</code>存入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void refreshInstanceInfo() &#123;</span><br><span class="line">		// 刷新配置</span><br><span class="line">        applicationInfoManager.refreshDataCenterInfoIfRequired();</span><br><span class="line">        // 刷新租约</span><br><span class="line">        applicationInfoManager.refreshLeaseInfoIfRequired();</span><br><span class="line"></span><br><span class="line">        InstanceStatus status;</span><br><span class="line">        // 健康检查 跳过</span><br><span class="line">        try &#123;</span><br><span class="line">            status = getHealthCheckHandler().getStatus(instanceInfo.getStatus());</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;Exception from healthcheckHandler.getStatus, setting status to DOWN&quot;, e);</span><br><span class="line">            status = InstanceStatus.DOWN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (null != status) &#123;</span><br><span class="line">            applicationInfoManager.setInstanceStatus(status);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><code>InstanceInfoReplicator#run()</code>首先会调用<code>discoveryClient.refreshInstanceInfo();</code><br>来刷新实例的信息。主要刷新两点</p>
<ul>
<li><p>刷新配置查看配置是否变化</p>
</li>
<li><p>刷新租约信息查看租约是否变化</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public void refreshDataCenterInfoIfRequired() &#123;</span><br><span class="line">		// 获取实例的HostName</span><br><span class="line">        String existingAddress = instanceInfo.getHostName();</span><br><span class="line"></span><br><span class="line">        String newAddress;</span><br><span class="line">        // 判断config是否为可刷新的config</span><br><span class="line">        if (config instanceof RefreshableInstanceConfig) &#123;</span><br><span class="line">            // Refresh data center info, and return up to date address</span><br><span class="line">            newAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(true);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            newAddress = config.getHostName(true);</span><br><span class="line">        &#125;</span><br><span class="line">        String newIp = config.getIpAddress();</span><br><span class="line">		 // 判断前后地址是否一样</span><br><span class="line">        if (newAddress != null &amp;&amp; !newAddress.equals(existingAddress)) &#123;</span><br><span class="line">            logger.warn(&quot;The address changed from : &#123;&#125; =&gt; &#123;&#125;&quot;, existingAddress, newAddress);</span><br><span class="line"></span><br><span class="line">            // :( in the legacy code here the builder is acting as a mutator.</span><br><span class="line">            // This is hard to fix as this same instanceInfo instance is referenced elsewhere.</span><br><span class="line">            // 重新创建instanceInfo并且将其设置为dirty</span><br><span class="line">            // We will most likely re-write the client at sometime so not fixing for now.</span><br><span class="line">            InstanceInfo.Builder builder = new InstanceInfo.Builder(instanceInfo);</span><br><span class="line">            builder.setHostName(newAddress).setIPAddr(newIp).setDataCenterInfo(config.getDataCenterInfo());</span><br><span class="line">            instanceInfo.setIsDirty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void refreshLeaseInfoIfRequired() &#123;</span><br><span class="line">        LeaseInfo leaseInfo = instanceInfo.getLeaseInfo();</span><br><span class="line">        if (leaseInfo == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当租约信息发生变化后重新创建租约并将instaceInfo设置为dirty</span><br><span class="line">        int currentLeaseDuration = config.getLeaseExpirationDurationInSeconds();</span><br><span class="line">        int currentLeaseRenewal = config.getLeaseRenewalIntervalInSeconds();</span><br><span class="line">        if (leaseInfo.getDurationInSecs() != currentLeaseDuration || leaseInfo.getRenewalIntervalInSecs() != currentLeaseRenewal) &#123;</span><br><span class="line">            LeaseInfo newLeaseInfo = LeaseInfo.Builder.newBuilder()</span><br><span class="line">                    .setRenewalIntervalInSecs(currentLeaseRenewal)</span><br><span class="line">                    .setDurationInSecs(currentLeaseDuration)</span><br><span class="line">                    .build();</span><br><span class="line">            instanceInfo.setLeaseInfo(newLeaseInfo);</span><br><span class="line">            instanceInfo.setIsDirty();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void setInstanceStatus(InstanceStatus status) &#123;</span><br><span class="line">        InstanceStatus next = instanceStatusMapper.map(status);</span><br><span class="line">        if (next == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        InstanceStatus prev = instanceInfo.setStatus(next);</span><br><span class="line">        if (prev != null) &#123;</span><br><span class="line">        // 前后状态不一致，监听器发出通知</span><br><span class="line">            for (StatusChangeListener listener : listeners.values()) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    listener.notify(new StatusChangeEvent(prev, next));</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    logger.warn(&quot;failed to notify listener: &#123;&#125;&quot;, listener.getId(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public synchronized InstanceStatus setStatus(InstanceStatus status) &#123;</span><br><span class="line">        if (this.status != status) &#123;</span><br><span class="line">            InstanceStatus prev = this.status;</span><br><span class="line">            this.status = status;</span><br><span class="line">            setIsDirty();</span><br><span class="line">            return prev;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>监听器发生通知后会执行<code>instanceInfoReplicator.onDemandUpdate();</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public boolean onDemandUpdate() &#123;</span><br><span class="line">		// 限流相关</span><br><span class="line">        if (rateLimiter.acquire(burstSize, allowedRatePerMinute)) &#123;</span><br><span class="line">            if (!scheduler.isShutdown()) &#123;</span><br><span class="line">                scheduler.submit(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        logger.debug(&quot;Executing on-demand update of local InstanceInfo&quot;);</span><br><span class="line">    </span><br><span class="line">                        Future latestPeriodic = scheduledPeriodicRef.get();</span><br><span class="line">                        if (latestPeriodic != null &amp;&amp; !latestPeriodic.isDone()) &#123;</span><br><span class="line">                            logger.debug(&quot;Canceling the latest scheduled update, it will be rescheduled at the end of on demand update&quot;);</span><br><span class="line">                            latestPeriodic.cancel(false);</span><br><span class="line">                        &#125;</span><br><span class="line">    </span><br><span class="line">                        InstanceInfoReplicator.this.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                return true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.warn(&quot;Ignoring onDemand update due to stopped scheduler&quot;);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            logger.warn(&quot;Ignoring onDemand update due to rate limiter&quot;);</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>latestPeriodic为上一次的执行的future，判断future有没有执行完毕，如果没有执行完毕则取消执行，因为此时的状态已经发生了改变，然后再重新执行<code>InstanceInfoReplicator#run()</code>方法重新发起注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractJerseyEurekaHttpClient implements EurekaHttpClient &#123;</span><br><span class="line">    // ...</span><br><span class="line">    @Override</span><br><span class="line">    public EurekaHttpResponse&lt;Void&gt; register(InstanceInfo info) &#123;</span><br><span class="line">        String urlPath = &quot;apps/&quot; + info.getAppName();</span><br><span class="line">        ClientResponse response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            Builder resourceBuilder = jerseyClient.resource(serviceUrl).path(urlPath).getRequestBuilder();</span><br><span class="line">            addExtraHeaders(resourceBuilder);</span><br><span class="line">            response = resourceBuilder</span><br><span class="line">                    .header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;)</span><br><span class="line">                    .type(MediaType.APPLICATION_JSON_TYPE)</span><br><span class="line">                    .accept(MediaType.APPLICATION_JSON)</span><br><span class="line">                    .post(ClientResponse.class, info);</span><br><span class="line">            return anEurekaHttpResponse(response.getStatus()).headers(headersOf(response)).build();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(&quot;Jersey HTTP POST &#123;&#125;/&#123;&#125; with instance &#123;&#125;; statusCode=&#123;&#125;&quot;, serviceUrl, urlPath, info.getId(),</span><br><span class="line">                        response == null ? &quot;N/A&quot; : response.getStatus());</span><br><span class="line">            &#125;</span><br><span class="line">            if (response != null) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>AbstractJerseyEurekaHttpClient#register()</code>发起注册</p>
<p>##3.Eureka-Server 接收注册</p>
<p>调用<code>ApplicationResource#addInstance()</code>接收注册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@POST</span><br><span class="line">    @Consumes(&#123;&quot;application/json&quot;, &quot;application/xml&quot;&#125;)</span><br><span class="line">    public Response addInstance(InstanceInfo info,</span><br><span class="line">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123;</span><br><span class="line">        logger.debug(&quot;Registering instance &#123;&#125; (replication=&#123;&#125;)&quot;, info.getId(), isReplication);</span><br><span class="line">        // 各种参数的校验</span><br><span class="line">        // validate that the instanceinfo contains all the necessary required fields</span><br><span class="line">        if (isBlank(info.getId())) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Missing instanceId&quot;).build();</span><br><span class="line">        &#125; else if (isBlank(info.getHostName())) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Missing hostname&quot;).build();</span><br><span class="line">        &#125; else if (isBlank(info.getIPAddr())) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Missing ip address&quot;).build();</span><br><span class="line">        &#125; else if (isBlank(info.getAppName())) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Missing appName&quot;).build();</span><br><span class="line">        &#125; else if (!appName.equals(info.getAppName())) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Mismatched appName, expecting &quot; + appName + &quot; but was &quot; + info.getAppName()).build();</span><br><span class="line">        &#125; else if (info.getDataCenterInfo() == null) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Missing dataCenterInfo&quot;).build();</span><br><span class="line">        &#125; else if (info.getDataCenterInfo().getName() == null) &#123;</span><br><span class="line">            return Response.status(400).entity(&quot;Missing dataCenterInfo Name&quot;).build();</span><br><span class="line">        &#125;</span><br><span class="line">		// AWS 相关跳过</span><br><span class="line">        // handle cases where clients may be registering with bad DataCenterInfo with missing data</span><br><span class="line">        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</span><br><span class="line">        if (dataCenterInfo instanceof UniqueIdentifier) &#123;</span><br><span class="line">            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();</span><br><span class="line">            if (isBlank(dataCenterInfoId)) &#123;</span><br><span class="line">                boolean experimental = &quot;true&quot;.equalsIgnoreCase(serverConfig.getExperimental(&quot;registration.validation.dataCenterInfoId&quot;));</span><br><span class="line">                if (experimental) &#123;</span><br><span class="line">                    String entity = &quot;DataCenterInfo of type &quot; + dataCenterInfo.getClass() + &quot; must contain a valid id&quot;;</span><br><span class="line">                    return Response.status(400).entity(entity).build();</span><br><span class="line">                &#125; else if (dataCenterInfo instanceof AmazonInfo) &#123;</span><br><span class="line">                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;</span><br><span class="line">                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);</span><br><span class="line">                    if (effectiveId == null) &#123;</span><br><span class="line">                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    logger.warn(&quot;Registering DataCenterInfo of type &#123;&#125; without an appropriate id&quot;, dataCenterInfo.getClass());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        registry.register(info, &quot;true&quot;.equals(isReplication));</span><br><span class="line">        return Response.status(204).build();  // 204 to be backwards compatible</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void register(final InstanceInfo info, final boolean isReplication) &#123;</span><br><span class="line">        int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">        if (info.getLeaseInfo() != null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) &#123;</span><br><span class="line">            leaseDuration = info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">        &#125;</span><br><span class="line">        super.register(info, leaseDuration, isReplication);</span><br><span class="line">        // 注册完毕后 server之间同步</span><br><span class="line">        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>PeerAwareInstanceRegistryImpl#register()</code>方法，接着调用<code>AbstractInstanceRegistry#register(...)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	// 使用读锁 </span><br><span class="line">            read.lock();</span><br><span class="line">            // registry是server端存放的所有client端信息，通过clientName获取这个APP所有的instance信息</span><br><span class="line">            Map&lt;String, Lease&lt;InstanceInfo&gt;&gt; gMap = registry.get(registrant.getAppName());</span><br><span class="line">            // 监控相关 跳过</span><br><span class="line">            REGISTER.increment(isReplication);</span><br><span class="line">            if (gMap == null) &#123;</span><br><span class="line">            // 如果此APP在Server没有注册过那么没有信息，新建一个Map用来存放这个APP的信息</span><br><span class="line">                final ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt; gNewMap = new ConcurrentHashMap&lt;String, Lease&lt;InstanceInfo&gt;&gt;();</span><br><span class="line">                // 将APP信息存放到Server端</span><br><span class="line">                gMap = registry.putIfAbsent(registrant.getAppName(), gNewMap);</span><br><span class="line">                if (gMap == null) &#123;</span><br><span class="line">                		// 信息存放成功，但此时还没有把APP的实例信息存入</span><br><span class="line">                    gMap = gNewMap;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 通过实例ID来获取已经存在的租约,ID由IP+APPName+Port构成实例的唯一标识</span><br><span class="line">            Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</span><br><span class="line">            // 如果已经存在租约(实例信息)那么取lastDirtyTimestamp大的那个，也就是最新的那个租约。</span><br><span class="line">            // Retain the last dirty timestamp without overwriting it, if there is already a lease</span><br><span class="line">            if (existingLease != null &amp;&amp; (existingLease.getHolder() != null)) &#123;</span><br><span class="line">                Long existingLastDirtyTimestamp = existingLease.getHolder().getLastDirtyTimestamp();</span><br><span class="line">                Long registrationLastDirtyTimestamp = registrant.getLastDirtyTimestamp();</span><br><span class="line">                logger.debug(&quot;Existing lease found (existing=&#123;&#125;, provided=&#123;&#125;&quot;, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br><span class="line"></span><br><span class="line">                // this is a &gt; instead of a &gt;= because if the timestamps are equal, we still take the remote transmitted</span><br><span class="line">                // InstanceInfo instead of the server local copy.</span><br><span class="line">                if (existingLastDirtyTimestamp &gt; registrationLastDirtyTimestamp) &#123;</span><br><span class="line">                    logger.warn(&quot;There is an existing lease and the existing lease&apos;s dirty timestamp &#123;&#125; is greater&quot; +</span><br><span class="line">                            &quot; than the one that is being registered &#123;&#125;&quot;, existingLastDirtyTimestamp, registrationLastDirtyTimestamp);</span><br><span class="line">                    logger.warn(&quot;Using the existing instanceInfo instead of the new instanceInfo as the registrant&quot;);</span><br><span class="line">                    registrant = existingLease.getHolder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            	   // 否则租约不存在认为这是一个新的注册</span><br><span class="line">                // The lease does not exist and hence it is a new registration</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    if (this.expectedNumberOfRenewsPerMin &gt; 0) &#123;</span><br><span class="line">                        // Since the client wants to cancel it, reduce the threshold</span><br><span class="line">                        // (1</span><br><span class="line">                        // for 30 seconds, 2 for a minute)</span><br><span class="line">                        this.expectedNumberOfRenewsPerMin = this.expectedNumberOfRenewsPerMin + 2;</span><br><span class="line">                        this.numberOfRenewsPerMinThreshold =</span><br><span class="line">                                (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                logger.debug(&quot;No previous lease information found; it is new registration&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 创建一个新的租约</span><br><span class="line">            Lease&lt;InstanceInfo&gt; lease = new Lease&lt;InstanceInfo&gt;(registrant, leaseDuration);</span><br><span class="line">     		  // 将旧租约的serviceUpTimestamp(开始服务时间)设置到新的租约上</span><br><span class="line">            if (existingLease != null) &#123;</span><br><span class="line">                lease.setServiceUpTimestamp(existingLease.getServiceUpTimestamp());</span><br><span class="line">            &#125;</span><br><span class="line">            // 将新的租约信息存入</span><br><span class="line">            gMap.put(registrant.getId(), lease);</span><br><span class="line">            // 将实例信息放入recentRegisteredQueue(最近注册队列中)</span><br><span class="line">            synchronized (recentRegisteredQueue) &#123;</span><br><span class="line">                recentRegisteredQueue.add(new Pair&lt;Long, String&gt;(</span><br><span class="line">                        System.currentTimeMillis(),</span><br><span class="line">                        registrant.getAppName() + &quot;(&quot; + registrant.getId() + &quot;)&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">            // This is where the initial state transfer of overridden status happens</span><br><span class="line">            if (!InstanceStatus.UNKNOWN.equals(registrant.getOverriddenStatus())) &#123;</span><br><span class="line">                logger.debug(&quot;Found overridden status &#123;&#125; for instance &#123;&#125;. Checking to see if needs to be add to the &quot;</span><br><span class="line">                                + &quot;overrides&quot;, registrant.getOverriddenStatus(), registrant.getId());</span><br><span class="line">                if (!overriddenInstanceStatusMap.containsKey(registrant.getId())) &#123;</span><br><span class="line">                    logger.info(&quot;Not found overridden id &#123;&#125; and hence adding it&quot;, registrant.getId());</span><br><span class="line">                    overriddenInstanceStatusMap.put(registrant.getId(), registrant.getOverriddenStatus());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            InstanceStatus overriddenStatusFromMap = overriddenInstanceStatusMap.get(registrant.getId());</span><br><span class="line">            if (overriddenStatusFromMap != null) &#123;</span><br><span class="line">                logger.info(&quot;Storing overridden status &#123;&#125; from map&quot;, overriddenStatusFromMap);</span><br><span class="line">                registrant.setOverriddenStatus(overriddenStatusFromMap);</span><br><span class="line">            &#125;</span><br><span class="line">			// 根据覆盖实例状态的规则设置实例的状态</span><br><span class="line">            // Set the status based on the overridden status rules</span><br><span class="line">            InstanceStatus overriddenInstanceStatus = getOverriddenInstanceStatus(registrant, existingLease, isReplication);</span><br><span class="line">            registrant.setStatusWithoutDirty(overriddenInstanceStatus);</span><br><span class="line"></span><br><span class="line">            // If the lease is registered with UP status, set lease service up timestamp</span><br><span class="line">            if (InstanceStatus.UP.equals(registrant.getStatus())) &#123;</span><br><span class="line">            	// 设置租约的开始服务时间</span><br><span class="line">                lease.serviceUp();</span><br><span class="line">            &#125;</span><br><span class="line">            // 设置实例的动作类型为新增</span><br><span class="line">            registrant.setActionType(ActionType.ADDED);</span><br><span class="line">            // 将租约放入最近变更队列中</span><br><span class="line">            recentlyChangedQueue.add(new RecentlyChangedItem(lease));</span><br><span class="line">            // 设置实例最后更新时间</span><br><span class="line">            registrant.setLastUpdatedTimestamp();</span><br><span class="line">            // 缓存失效</span><br><span class="line">            invalidateCache(registrant.getAppName(), registrant.getVIPAddress(), registrant.getSecureVipAddress());</span><br><span class="line">            logger.info(&quot;Registered instance &#123;&#125;/&#123;&#125; with status &#123;&#125; (replication=&#123;&#125;)&quot;,</span><br><span class="line">                    registrant.getAppName(), registrant.getId(), registrant.getStatus(), isReplication);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">        	// 释放读锁</span><br><span class="line">            read.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Lease&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    enum Action &#123;</span><br><span class="line">        Register, Cancel, Renew</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static final int DEFAULT_DURATION_IN_SECS = 90;</span><br><span class="line">	// 此处虽然是范型，但实际存的是instanceInfo</span><br><span class="line">    private T holder;</span><br><span class="line">    // 失效时间戳</span><br><span class="line">    private long evictionTimestamp;</span><br><span class="line">    // 注册时间戳</span><br><span class="line">    private long registrationTimestamp;</span><br><span class="line">    // 服务时间戳</span><br><span class="line">    private long serviceUpTimestamp;</span><br><span class="line">    // Make it volatile so that the expiration task would see this quicker</span><br><span class="line">    private volatile long lastUpdateTimestamp;</span><br><span class="line">    private long duration;</span><br><span class="line"></span><br><span class="line">    public Lease(T r, int durationInSecs) &#123;</span><br><span class="line">        holder = r;</span><br><span class="line">        registrationTimestamp = System.currentTimeMillis();</span><br><span class="line">        lastUpdateTimestamp = registrationTimestamp;</span><br><span class="line">        duration = (durationInSecs * 1000);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">    public void serviceUp() &#123;</span><br><span class="line">        if (serviceUpTimestamp == 0) &#123;</span><br><span class="line">            serviceUpTimestamp = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setServiceUpTimestamp(long serviceUpTimestamp) &#123;</span><br><span class="line">        this.serviceUpTimestamp = serviceUpTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getServiceUpTimestamp() &#123;</span><br><span class="line">        return serviceUpTimestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public T getHolder() &#123;</span><br><span class="line">        return holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server中存放的信息结构为<code>Map&lt;String, Map&lt;String, Lease&lt;InstanceInfo&gt;&gt;&gt;</code>，实际为<code>Map&lt;APPName, Map&lt;instanceId, Lease&lt;InstanceInfo&gt;&gt;&gt;</code>。</p>
<p>本文参考–<a href="http://www.iocoder.cn/Eureka/instance-registry-register/" target="_blank" rel="noopener">芋道源码-Eureka 源码解析 —— 应用实例注册发现（一）之注册</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/02/26/浅析Eureka应用实例注册/" data-id="cjsl3kyvt0000wn1kbz2s58gk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/02/26/浅析Eureka应用实例注册/">浅析Eureka应用实例注册</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 ChuanShanJun<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>